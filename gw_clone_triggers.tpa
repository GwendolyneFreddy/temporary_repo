/* ========================================================================================================== *
 *  v 1.0.0                                                                                                   *
 *                                                                                                            *
 *                      F U N C T I O N S    &    M A C R O S    :    A R E    F I L E S                      *
 *                                                                                                            *
 *             Originally designed by Gwendolyne For Menace sur le Royaume de Diamant Éternel mod.            *
 *                                                                                                            *
 * ========================================================================================================== */

/* ====================================================================================================================================================== *
 *                                                                                                                                                        *
 *  OVERALL FUNCTIONS and MACROS                                                                                                                          *
 *  ----------------------------                                                                                                                          *
 *  - FONCTION GW_REINCLUDE                     :                                                                                         => line #  50   *
 *                                                  INTÉGRATION d'une sous-routine tp2 dans une routine existante.                                        *
 *  - MACRO GW_DEF_AREA_OFFSETS                 :   LOADS the main offsets used to patch ARE files.                                       => line #  70   *
 *                                                  DÉFINITION des offsets généraux des fichiers ARE.                                                     *
 *  - FUNCTION GW_READ_AREA_STRUCTURE           :   READS the main offsets values in a ARE file.                                          => line # 163   *
 *                                                  LECTURE des valeurs des offsets généraux d'un fichier ARE.                                            *
 *  - MACRO GW_READ_AREA_REGION_STRUCTURE       :   READS the main offsets values used to patch a region in a ARE file.                   => line # 282   *
 *                                                  LECTURE des valeurs des offsets utilisés pour modifier une région dans un fichier ARE.                *
 *  - MACRO GW_READ_AREA_DOOR_STRUCTURE         :   READS the main offsets values used to patch a door in a ARE file.                     => line # 334   *
 *                                                  LECTURE des valeurs des offsets utilisés pour modifier une porte dans un fichier ARE.                 *
 *                                                                                                                                                        *
 *  FUNCTIONS and MACROS RELATIVE TO AREA SECTIONS PATCHING                                                                                               *
 *  -------------------------------------------------------                                                                                               *
 *  - GW_PARSE_FLAGS                            :   MODIFIES the flag value of a region in a ARE file.                                    => line # 396   *
 *                                                  MODIFICATION de la valeur du flag d'une région d'un fichier ARE.                                      *
 *  - FUNCTION GW_CLONE_AREA_TRIGGER            :   CLONE an existing trigger in a ARE file.                                              => line # 630   *
 *                                                  CLONAGE d'un trigger existant dans une carte.                                                         *
 *   More to come...                                                                                                                                      *
 *  - FUNCTION GW_CLONE_AREA_DOOR               :   READS a door settings and STORE them to patch or copy them later.                     => line #       *
 *                                                  LECTURE et STOCKAGE des paramètres d'une porte pour la cloner ou la modifier.                         *
 *  - MACRO GW_ADD_AREA_DOOR                    :   AUTO-GENERATE and LAUNCH the fj_are_structure function to add a new door.             => line #       *
 *                                                  GÉNÉRATION automatique et LANCEMENT de la fonction fj_are_structure pour ajouter une porte.           *
 *  - FUNCTION GW_CLONE_AREA_REGION             :   READS a region settings and STORE them to patch or copy them later.                   => line #       *
 *                                                  LECTURE et STOCKAGE des paramètres d'une région pour la cloner ou la modifier.                        *
 *  - MACRO GW_ADD_AREA_REGION                  :   AUTO-GENERATE and LAUNCH the fj_are_structure function to add a new region.           => line #       *
 *                                                  GÉNÉRATION automatique et LANCEMENT de la fonction fj_are_structure pour ajouter une region.          *
 * ====================================================================================================================================================== */


/* ============================================================================ *
 *                                                                              *
 *          O V E R A L L    F U N C T I O N S    a n d    M A C R O S          *
 *                                                                              *
 * ============================================================================ */

/* ======================================================================================== *
 *  FONCTION GW_REINCLUDE : INTÉGRATION d'une sous-routine tp2 dans une routine existante.  *
 * ======================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_REINCLUDE~
    STR_VAR GW_input = ""       // Liste de commandes ou de fonctions à effectuer.
BEGIN

	INNER_ACTION BEGIN
		<<<<<<<< temp_file
			%GW_input%
		>>>>>>>>
		COPY - temp_file ~temp_file2~ EVALUATE_BUFFER
	END
//	PATCH_PRINT ~%GW_input%~
	PATCH_REINCLUDE ~temp_file2~

END	// of DEFINE_PATCH_FUNCTION


/* =============================================================================== *
 *  MACRO GW_DEF_AREA_OFFSETS : DÉFINITION des offsets généraux des fichiers ARE.  *
 *                              LOADS the main offsets used to patch ARE files.    *
 * ------------------------------------------------------------------------------- *
 *  Lancée une seule fois avant de modifier une ou plusieurs cartes.               *
 *  Run once before patching one or several are files.                             *
 * =============================================================================== */

DEFINE_ACTION_MACRO ~GW_DEF_AREA_OFFSETS~ 
BEGIN
// Section and file sizes
	OUTER_SET GW_are_min_size               = 0x11b	// Area minimum size
	OUTER_SET GW_are_actor_size             = 0x110	// Size of actors section
	OUTER_SET GW_are_region_size            = 0xc4	// Size of regions section
	OUTER_SET GW_are_spawn_size             = 0xc8	// Size of spawn points section
	OUTER_SET GW_are_entrance_size          = 0x68	// Size of entrances section
	OUTER_SET GW_are_container_size         = 0xc0	// Size of containers section
	OUTER_SET GW_are_itm_size               = 0x14	// Size of items section
	OUTER_SET GW_are_vertex_size            = 0x04	// Size of vertices section                 - size of one set of X, Y coordinates
	OUTER_SET GW_are_ambient_size           = 0xd4	// Size of ambients section
	OUTER_SET GW_are_variable_size          = 0x54	// Size of variables section                - not used in PS:T ou 0x50 IESPD
	OUTER_SET GW_are_door_size              = 0xc8	// Size of doors section
	OUTER_SET GW_are_animation_size         = 0x4c	// Size of animations section
	OUTER_SET GW_are_til_size               = 0x6c	// Size of tiled objects section 0          - not used in PS:T
	OUTER_SET GW_are_song_size              = 0x90	// Size of songs section                    - no count, offset only
	OUTER_SET GW_are_rest_size              = 0xe4	// Size of rest interruptions               - no count, offset only
	OUTER_SET GW_are_mapnote_size           = 0x34	// Size of  Automap notes section           - not used in PS:T ?
	OUTER_SET GW_are_project_size           = 0x1a	// Size of Projectile Traps section         - only used in BG2? or 0x1C IESDP ??? waiting for Avenger answer to validate it.
// File header
	OUTER_SET GW_are_wed_of                 = 0x008 // Area WED
	OUTER_SET GW_are_flag1_of               = 0x014 /* Area flag (AREAFLAG.IDS) = BIT0: Save allowed - BIT1: Tutorial area (not BG1) - BIT2: Dead magic zone - BIT3: Dream
                                                        BGEE = BIT0: Save not allowed - BIT1: Tutorial area - BIT2: Dead magic zone - BIT3: Dream
                                                        BIT4: Player1 death does not end the game - BIT5: Resting not allowed - BIT6: Travel not allowed */
	OUTER_SET GW_are_NArea_of               = 0x018	// Offset to Resref of the area to the North of this area
	OUTER_SET GW_are_NArea_flags_of         = 0x020 // Offset to North area flags = BIT0: Party Required - BIT1: Party Enabled
	OUTER_SET GW_are_EArea_of               = 0x024	// Offset to Resref of the area to the East of this area
	OUTER_SET GW_are_EArea_flags_of         = 0x02c	// Offset to East area flags = BIT0: Party Required - BIT1: Party Enabled
	OUTER_SET GW_are_SArea_of               = 0x030	// Offset to Resref of the area to the South of this area
	OUTER_SET GW_are_SArea_flags_of         = 0x038	// Offset to South area flags = BIT0: Party Required - BIT1: Party Enabled
	OUTER_SET GW_are_WArea_of               = 0x03c	// Offset to Resref of the area to the West of this area
	OUTER_SET GW_are_WArea_flags_of         = 0x044	// Offset to West area flags = BIT0: Party Required - BIT1: Party Enabled
	OUTER_SET GW_are_flag2_of               = 0x048 /* Area flags (AREATYPE.IDS) =  BIT0: Outdoor - BIT1: Day/night - BIT2: Weather - BIT3: City - BIT4: Forest - BIT5: Dungeon
                                                                                    BIT6: Extended night - BIT7: Can rest indoors */
	OUTER_SET GW_are_rain_prob_of           = 0x04a	// Offset to Rain probability
	OUTER_SET GW_are_snow_prob_of           = 0x04c	// Offset to Snow probability
//	OUTER_SET GW_are_fog_prob_of            = 0x04e 	2 (word) 	// Offset to Fog probability (BGEE only)
	OUTER_SET GW_are_lightg_prob_of         = 0x050	// Offset to Lightning probability
//	OUTER_SET GW_are_wind_speed_of          = 0x052 	2 (word)	// BG1:TotS, IWD:ToTL, BG2:ToB: Wind speed (unused?) - BGEE: Overlay transparency (only first byte)
 	OUTER_SET GW_are_actors_of              = 0x054 // Offset to actors
	OUTER_SET GW_are_actors_nb              = 0x058	// Count of actors
	OUTER_SET GW_are_regions_nb             = 0x05a	// Count of regions
	OUTER_SET GW_are_regions_of             = 0x05c	// Offset to regions
	OUTER_SET GW_are_region_text_of         = 0x64 	// Offset to Information text (for info points) : SPECIAL (used by homemade functions to avoid lines of codes)
	OUTER_SET GW_are_spawns_of              = 0x060	// Offset to spawn points
	OUTER_SET GW_are_spawns_nb              = 0x064	// Count of spawn points
	OUTER_SET GW_are_entrances_of           = 0x068	// Offset to entrances
	OUTER_SET GW_are_entrances_nb           = 0x06c	// Count of entrances
	OUTER_SET GW_are_containers_of          = 0x070	// Offset to containers
	OUTER_SET GW_are_containers_nb          = 0x074	// Count of containers
	OUTER_SET GW_are_container_string_of    = 0x84	// Offset to Lockpick string : SPECIAL (used by homemade functions to avoid lines of codes)
	OUTER_SET GW_are_items_nb               = 0x076	// Count of items
	OUTER_SET GW_are_items_of               = 0x078	// Offset to items
	OUTER_SET GW_are_vertices_of            = 0x07c	// Offset to vertices
	OUTER_SET GW_are_vertices_nb            = 0x080	// Count of vertices
	OUTER_SET GW_are_ambients_nb            = 0x082	// Count of ambients
	OUTER_SET GW_are_ambients_of            = 0x084	// Offset to ambients
	OUTER_SET GW_are_variables_of           = 0x088	// Offset to variables                      - not used in PS:T
	OUTER_SET GW_are_variables_nb           = 0x08c	// Count of variables                       - not used in PS:T
/*	OUTER_SET GW_are_tiled_object_flag_of   = 0x090	// Offset to tiled object flags
	OUTER_SET GW_are_tiled_object_flag_nb   = 0x092	// Count of tiled object flags */
	OUTER_SET GW_are_script_of              = 0x094	// Area script
/*	OUTER_SET GW_are_explored_size          = 0x09c	// Size of explored bitmask section         - not applicable    - no count, offset only
	OUTER_SET GW_are_explored_of            = 0x0a0	// Offset to explored bitmask               - no count, offset only
*/	OUTER_SET GW_are_doors_nb               = 0x0a4	// Count of doors
	OUTER_SET GW_are_doors_of               = 0x0a8	// Offset to doors
	OUTER_SET GW_are_door_string_of         = 0x98	// Offset to Lockpick string : SPECIAL (used by homemade functions to avoid lines of codes)
	OUTER_SET GW_are_animations_nb          = 0x0ac	// Count of animations
	OUTER_SET GW_are_animations_of          = 0x0b0	// Offset to animation
	OUTER_SET GW_are_tiles_nb               = 0x0b4	// Count of tiled objects                   - not used in PS:T
	OUTER_SET GW_are_tiles_of               = 0x0b8	// Offset to tiled objects                  - not used in PS:T
	OUTER_SET GW_are_songs_of               = 0x0bc	// Offset to song entries                   - no count, offset only
	OUTER_SET GW_are_rest_of                = 0x0c0	// Offset to rest interruptions             - no count, offset only
	OUTER_SET GW_are_mapnotes_of            = 0x0c4	// Offset of the automap notes section      - not used in PS:T = 0xFFFFFFFF
	OUTER_SET GW_are_mapnotes_nb            = 0x0c8	// Count of the automap notes section       - Ps:T = Offset of the automap note section
	OUTER_SET GW_are_note_string_of         = 0x04 	// Note text (dialog.tlk or TOH/TOT file) : SPECIAL (used by homemade functions to avoid lines of codes)
	OUTER_SET GW_are_proj_traps_of          = 0x0cc	// Offset to the Projectile Traps section   - Ps:T = Number of entries in the automap note section
	OUTER_SET GW_are_proj_traps_nb          = 0x0d0	// Count of the Projectile Traps section    - only used in BG2?
	OUTER_SET GW_are_rest_movie_Day_of      = 0x0d4	// BG2: ToB, BGEE - Rest movie (day)
	OUTER_SET GW_are_rest_movie_Night_of    = 0x0dc	// BG2: ToB, BGEE - Rest movie (night)

END	// of DEFINE_ACTION_MACRO


/* ============================================================================================== *
 *  FUNCTION GW_READ_AREA_STRUCTURE : LECTURE des valeurs des offsets généraux d'un fichier ARE.  *
 *                                    READS the main offsets values in a ARE file.                *
 * ---------------------------------------------------------------------------------------------- *
 *  Lancée systématiquement avant de modifier un élément d'une carte.                             *
 *  Run before patching any section in a are file.                                                *
 * ============================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_READ_AREA_STRUCTURE~ 
    RET GW_are_wed              // Area WED
        GW_are_flag1            // Area flag (AREAFLAG.IDS)  = BIT0: Save allowed - BIT1: Tutorial area (not BG1) - BIT2: Dead magic zone - BIT3: Dream
        GW_are_flag2            // Area flags (AREATYPE.IDS) = BIT0: Outdoor - BIT1: Day/night - BIT2: Weather - BIT3: City - BIT4: Forest - BIT5: Dungeon - BIT6: Extended night - BIT7: Can rest indoors
/*
        GW_are_NArea            // Resref of the area to the North of this area                     | Unused for the moment
        GW_are_NArea_flags      // North area flags = BIT0: Party Required - BIT1: Party Enabled    | id.
        GW_are_EArea            // Resref of the area to the East of this area                      | id.
        GW_are_EArea_flags      // East area flags = BIT0: Party Required - BIT1: Party Enabled     | id.
        GW_are_SArea            // Resref of the area to the South of this area                     | id.
        GW_are_SArea_flags      // South area flags = BIT0: Party Required - BIT1: Party Enabled    | id.
        GW_are_WArea            // Resref of the area to the West of this area                      | id.
        GW_are_WArea_flags      // West area flags = BIT0: Party Required - BIT1: Party Enabled     | id.
*/        GW_are_rain_prob        // Rain probability
        GW_are_snow_prob        // Snow probability
        GW_are_lightg_prob      // Lightning probability
        GW_are_actors_num       // Count of actors
        GW_are_actors_off       // Offset to actors
        GW_are_regions_num      // Count of regions
        GW_are_regions_off      // Offset to regions
        GW_are_spawns_off       // Offset to spawn points
        GW_are_spawns_num       // Count of spawn points
        GW_are_entrances_off	// Offset to entrances
        GW_are_entrances_num	// Count of entrances
        GW_are_containers_off	// Offset to containers
        GW_are_containers_num	// Count of containers
        GW_are_items_num        // Count of items
        GW_are_items_off        // Offset to items
        GW_are_vertices_off     // Offset to vertices
        GW_are_vertices_num     // Count of vertices
        GW_are_ambients_num     // Count of ambients
        GW_are_ambients_off     // Offset to ambients
        GW_are_variables_off	// Offset to variables                      - not used in PS:T
        GW_are_variables_num	// Count of variables                       - not used in PS:T
        GW_are_script           // Area script
//        GW_are_explored_off     // Offset to explored bitmask               - no count, offset only | Unused for the moment
        GW_are_doors_num        // Count of doors
        GW_are_doors_off        // Offset to doors
        GW_are_animations_num	// Count of animations
        GW_are_animations_off	// Offset to animation
/*        GW_are_tiles_flag_off	// Offset to tiled object flags                                     | Unused for the moment
        GW_are_tiles_flag_num	// Count of tiled object flags                                      | id.*/
        GW_are_tiles_num        // Count of tiled objects                   - not used in PS:T
        GW_are_tiles_off        // Offset to tiled objects                  - not used in PS:T
        GW_are_songs_off        // Offset to song entries
        GW_are_rest_off         // Offset to rest interruptions
        GW_are_mapnotes_off     // Offset of the automap notes section      - not used in PS:T : 0xFFFFFFFF
        GW_are_mapnotes_num     // Count of the automap notes section       - not used in PS:T
        GW_are_proj_traps_off   // Offset to the Projectile Traps section   - only used in BG2?
        GW_are_proj_traps_num   // Count of the Projectile Traps section    - only used in BG2?
        GW_are_movie_Day        // BG2: ToB - Rest movie (day)
        GW_are_movie_Night      // BG2: ToB - Rest movie (night)
BEGIN

	READ_ASCII GW_are_wed_of                GW_are_wed (8) NULL         // Area WED
	READ_LONG  GW_are_flag1_of              GW_are_flag1                // Area flag (AREAFLAG.IDS) = BIT0: Save allowed - BIT1: Tutorial area (not BG1) - BIT2: Dead magic zone - BIT3: Dream
	READ_SHORT GW_are_flag2_of              GW_are_flag2                // Area flags (AREATYPE.IDS) = BIT0: Outdoor - BIT1: Day/night - BIT2: Weather - BIT3: City - BIT4: Forest - BIT5: Dungeon - BIT6: Extended night - BIT7: Can rest indoors
/*	READ_ASCII GW_are_NArea_of              GW_are_NArea (8) NULL       // Resref of the area to the North of this area
	READ_LONG  GW_are_NArea_flags_of        GW_are_NArea_flags          // North area flags = BIT0: Party Required - BIT1: Party Enabled
	READ_ASCII GW_are_EArea_of              GW_are_EArea (8) NULL       // Resref of the area to the East of this area
	READ_LONG  GW_are_EArea_flags_of        GW_are_EArea_flags          // East area flags = BIT0: Party Required - BIT1: Party Enabled
	READ_ASCII GW_are_SArea_of              GW_are_SArea (8) NULL       // Resref of the area to the South of this area
	READ_LONG  GW_are_SArea_flags_of        GW_are_SArea_flags          // South area flags = BIT0: Party Required - BIT1: Party Enabled
	READ_ASCII GW_are_WArea_of              GW_are_WArea (8) NULL       // Resref of the area to the West of this area
	READ_LONG  GW_are_WArea_flags_of        GW_are_WArea_flags          // West area flags = BIT0: Party Required - BIT1: Party Enabled
*/	READ_SHORT GW_are_rain_prob_of          GW_are_rain_prob            // Rain probability
	READ_SHORT GW_are_snow_prob_of          GW_are_snow_prob            // Snow probability
	READ_SHORT GW_are_lightg_prob_of        GW_are_lightg_prob          // Lightning probability
	READ_LONG  GW_are_actors_of             GW_are_actors_off           // Offset to actors
	READ_SHORT GW_are_actors_nb             GW_are_actors_num           // Count of actors
	READ_SHORT GW_are_regions_nb            GW_are_regions_num          // Count of regions
	READ_LONG  GW_are_regions_of            GW_are_regions_off          // Offset to regions
	READ_LONG  GW_are_spawns_of             GW_are_spawns_off           // Offset to spawn points
	READ_LONG  GW_are_spawns_nb             GW_are_spawns_num           // Count of spawn points
	READ_LONG  GW_are_entrances_of          GW_are_entrances_off        // Offset to entrances
	READ_LONG  GW_are_entrances_nb          GW_are_entrances_num        // Count of entrances
	READ_LONG  GW_are_containers_of         GW_are_containers_off       // Offset to containers
	READ_SHORT GW_are_containers_nb         GW_are_containers_num       // Count of containers
	READ_SHORT GW_are_items_nb              GW_are_items_num            // Count of items
	READ_LONG  GW_are_items_of              GW_are_items_off            // Offset to items
	READ_LONG  GW_are_vertices_of           GW_are_vertices_off         // Offset to vertices
	READ_SHORT GW_are_vertices_nb           GW_are_vertices_num         // Count of vertices
	READ_SHORT GW_are_ambients_nb           GW_are_ambients_num         // Count of ambients
	READ_LONG  GW_are_ambients_of           GW_are_ambients_off         // Offset to ambients
	READ_LONG  GW_are_variables_of          GW_are_variables_off        // Offset to variables                      - not used in PS:T
	READ_LONG  GW_are_variables_nb          GW_are_variables_num        // Count of variables                       - not used in PS:T
	READ_ASCII GW_are_script_of             GW_are_script (8) NULL      // Area script
//	READ_LONG  GW_are_explored_of           GW_are_explored_off         // Offset to explored bitmask               - no count, offset only
//	SET GW_are_explo_num	= 1                                         // Only 1 Explored Bitmap section per area  - This isn't really needed.
	READ_LONG  GW_are_doors_nb              GW_are_doors_num            // Count of doors
	READ_LONG  GW_are_doors_of              GW_are_doors_off            // Offset to doors
	READ_LONG  GW_are_animations_nb         GW_are_animations_num       // Count of animations
	READ_LONG  GW_are_animations_of         GW_are_animations_off       // Offset to animation
/*	READ_SHORT GW_are_tiled_object_flag_of	GW_are_tiles_obj_flag_off   // Offset to tiled object flags
	READ_SHORT GW_are_tiled_object_flag_nb	GW_are_tiles_obj_flag_num   // Count of tiled object flags */
	READ_LONG  GW_are_tiles_nb              GW_are_tiles_num            // Count of tiled objects                   - not used in PS:T
	READ_LONG  GW_are_tiles_of              GW_are_tiles_off            // Offset to tiled objects                  - not used in PS:T
//	SET GW_are_song_num		= 1                                         // Only 1 song section per area             - This isn't really needed.
	READ_LONG  GW_are_songs_of              GW_are_songs_off            // Offset to song entries
//	SET GW_are_rest_num		= 1                                         // Only 1 rest section per area             - This isn't really needed.
	READ_LONG  GW_are_rest_of               GW_are_rest_off             // Offset to rest interruptions
	READ_LONG  GW_are_mapnotes_of           GW_are_mapnotes_off         // Offset of the automap notes section      - not used in PS:T : 0xFFFFFFFF
	READ_LONG  GW_are_mapnotes_nb           GW_are_mapnotes_num         // Count of the automap notes section       - not used in PS:T
	READ_LONG  GW_are_proj_traps_of         GW_are_proj_traps_off       // Offset to the Projectile Traps section   - only used in BG2?
	READ_LONG  GW_are_proj_traps_nb         GW_are_proj_traps_num       // Count of the Projectile Traps section    - only used in BG2?
	READ_ASCII GW_are_rest_movie_Day_of     GW_are_movie_Day (8) NULL   // BG2: ToB - Rest movie (day)
	READ_ASCII GW_are_rest_movie_Night_of   GW_are_movie_Night (8) NULL // BG2: ToB - Rest movie (night)

END	// of DEFINE_PATCH_FUNCTION


/* ============================================================================================================================== *
 *  MACRO GW_READ_AREA_REGION_STRUCTURE : LECTURE des valeurs des offsets utilisés pour modifier une région dans un fichier ARE.  *
 *                                        READS the main offsets values used to patch a region in a ARE file.                     *
 * ------------------------------------------------------------------------------------------------------------------------------ *
 *  Lancée systématiquement avant de modifier une région d'une carte.                                                             *
 *  Run before patching a region in a area.                                                                                       *
 * ------------------------------------------------------------------------------------------------------------------------------ *
 *  VARIABLE pré-définie (predefined) : GW_region_offset                                                                          *
 *	SET GW_region_offset = "%GW_are_regions_off%" + ("%GW_are_region_size%" * r) with r = region index                            *
 * ============================================================================================================================== */

DEFINE_PATCH_MACRO ~GW_READ_AREA_REGION_STRUCTURE~ 
BEGIN

	READ_ASCII  (GW_region_offset + 0x0000) fj_name (32) NULL              // Region name
	READ_SHORT  (GW_region_offset + 0x0020) fj_type                        // Region type (0=trap, 1=info, 2=travel)
	READ_SHORT  (GW_region_offset + 0x0022) fj_box_left                    // leftmost X coordinate of the regions bounding box
	READ_SHORT  (GW_region_offset + 0x0024) fj_box_top                     // topmost Y coordinate of the regions bounding box
	READ_SHORT  (GW_region_offset + 0x0026) fj_box_right                   // rightmost X coordinate of the regions bounding box
	READ_SHORT  (GW_region_offset + 0x0028) fj_box_bottom                  // bottommost Y coordinate of the regions bounding box
	READ_SHORT  (GW_region_offset + 0x002a) gw_reg_nb_vertices             // Count of vertices composing the perimeter of this region (Number of Vertex Pairs for current region)
	READ_LONG   (GW_region_offset + 0x002c) gw_reg_first_vertex            // Index of first vertex for this region
//	READ_LONG   (GW_region_offset + 0x0030) 	Trigger value
	READ_LONG   (GW_region_offset + 0x0034) fj_cursor_idx                   // Regions mouse cursor index (Cursor Index - points to a graphic in cursors.bam)
	READ_ASCII  (GW_region_offset + 0x0038) fj_destination_area (8) NULL    // Destination area resource reference (for travel regions)
	READ_ASCII  (GW_region_offset + 0x0040) fj_destination_name (32) NULL   // Entrance name in the destination area (for travel regions)
	READ_LONG   (GW_region_offset + 0x0060) fj_flags                        /* Flag bits set in bit format which are read right to left - 0=off; 1=on :
                                                                                BIT0: Key required [NI = Locked] - BIT1: Reset trap [NI = Trap resets] for proximity triggers - BIT2: Party Required (for travel triggers)
                                                                                BIT3: Detectable [NI = Trap detectable] - BIT4: NPC activates [NI = Trap set off by enemy] - BIT5: Active in tutorial area only [NI = Tutorial trigger]
                                                                                BIT6: Anyone activates [NI = Trap set off by NPC] - BIT7: No string [NI = Trigger silent] - BIT8: Trigger Deactivated (for proximity triggers)
                                                                                BIT9: Party only [NI = Cannot by passed by NPC] - BIT10: Alternative point [NI = Use activation point] - BIT11: Door closed [NI = Connected to door]*/
	READ_LONG   (GW_region_offset + 0x0064) fj_info_point_strref             // Information text string reference (for info points, default -1)
	READ_SHORT  (GW_region_offset + 0x0068) fj_trap_detect                   /* Trap detection difficulty percentage. N.B. A value of 100 or higher will prevent the trap from
																			   being detected (e.g. via thief skills, Find Traps effect). */
	READ_SHORT  (GW_region_offset + 0x006a) fj_trap_remove                   // Trap removal difficulty percentage
	READ_SHORT  (GW_region_offset + 0x006c) fj_trap_active                   // Whether the trap is set (0=no, 1=yes)
	READ_SHORT  (GW_region_offset + 0x006e) fj_trap_status                   // Whether the trap is detected (0=no, 1=yes)
	READ_SHORT  (GW_region_offset + 0x0070) fj_loc_x                         // Trap launch X coordinate
	READ_SHORT  (GW_region_offset + 0x0072) fj_loc_y                         // Trap launch Y coordinate
	READ_ASCII  (GW_region_offset + 0x0078) fj_key_resref (8) NULL           // Filename of the regions key
	READ_ASCII  (GW_region_offset + 0x007c) fj_reg_script (8) NULL           // Filename of the Region script
	READ_SHORT  (GW_region_offset + 0x0084) fj_alt_x                         // Alternative use point X coordinate
	READ_SHORT  (GW_region_offset + 0x0086) fj_alt_y                         // Alternative use point Y coordinate
/*	READ_ASCII  (GW_region_offset + 0x00ac) fj_sound (8) NULL                // Sound (PST, PSTEE)
	READ_SHORT  (GW_region_offset + 0x00b4) fj_talk_loc_x                    // Talk location point X coordinate (PST, PSTEE)
	READ_SHORT  (GW_region_offset + 0x00b6) fj_talk_loc_y                    // Talk location point Y coordinate (PST, PSTEE)
	READ_ASCII  (GW_region_offset + 0x00b8) fj_speaker_strref (4) NULL       // Speaker name (PST, PSTEE) (default -1)
	READ_ASCII  (GW_region_offset + 0x00bc) fj_dialog (8) NULL               // Dialog file (PST, PSTEE)
*/
END	// of DEFINE_PATCH_MACRO


/* =========================================================================================================================== *
 *  MACRO GW_READ_AREA_DOOR_STRUCTURE : LECTURE des valeurs des offsets utilisés pour modifier une porte dans un fichier ARE.  *
 *									    READS the main offsets values used to patch a door in a ARE file.                      *
 * --------------------------------------------------------------------------------------------------------------------------- *
 *  Lancée systématiquement avant de modifier une porte d'une carte.                                                           *
 *  Run before patching a door in an area.                                                                                     *
 * --------------------------------------------------------------------------------------------------------------------------- *
 *  VARIABLE pré-définie (predefined) : GW_door_offset                                                                         *
 *	SET GW_door_offset = "%GW_are_doors_off%" + ("%GW_are_door_size%" * d) with d = door index                                 *
 * =========================================================================================================================== */

DEFINE_PATCH_MACRO ~GW_READ_AREA_DOOR_STRUCTURE~ 
BEGIN

	READ_ASCII	(GW_door_offset + 0x0000) fj_name (32) NULL             // Name
	READ_ASCII	(GW_door_offset + 0x0020) fj_door_wed_id (8) NULL       // Door ID (to link with WED)
	READ_LONG	(GW_door_offset + 0x0028) fj_flags                      // Flags
	READ_SHORT	(GW_door_offset + 0x0038) fj_open_box_left              // Minimum bounding box of the door polygon (when open)
	READ_SHORT	(GW_door_offset + 0x003a) fj_open_box_top               // Minimum bounding box of the door polygon (when open)
	READ_SHORT	(GW_door_offset + 0x003c) fj_open_box_right             // Minimum bounding box of the door polygon (when open)
	READ_SHORT	(GW_door_offset + 0x003e) fj_open_box_bottom            // Minimum bounding box of the door polygon (when open)
	READ_SHORT	(GW_door_offset + 0x0040) fj_closed_box_left            // Minimum bounding box of the door polygon (when closed)
	READ_SHORT	(GW_door_offset + 0x0042) fj_closed_box_top             // Minimum bounding box of the door polygon (when closed)
	READ_SHORT	(GW_door_offset + 0x0044) fj_closed_box_right           // Minimum bounding box of the door polygon (when closed)
	READ_SHORT	(GW_door_offset + 0x0046) fj_closed_box_bottom          // Minimum bounding box of the door polygon (when closed)
//	READ_LONG	(GW_door_offset + 0x0048) GW_open_cell_offset           // Index of first "vertex" in the impeded cell block (when open). These entries are x.y coordinates in the area search map. When the door is open, these cells cannot be entered by any object.
//	READ_SHORT	(GW_door_offset + 0x004c) GW_open_cell_num              // Count of "vertices" in impeded cell block (when open)
//	READ_SHORT	(GW_door_offset + 0x004e) GW_closed_cell_num            // Count of "vertices" in impeded cell block (when closed)
//	READ_LONG	(GW_door_offset + 0x0050) GW_closed_cell_offset         // Index of first "vertex" in the impeded cell block (when closed). These entries are x.y coordinates in the area search map. When the door is closed, these cells cannot be entered by any object.
	READ_ASCII	(GW_door_offset + 0x0058) fj_door_open_wav (8) NULL     // Door open sound
	READ_ASCII	(GW_door_offset + 0x0060) fj_door_close_wav (8) NULL    // Door close sound
	READ_LONG	(GW_door_offset + 0x0068) fj_cursor_idx                 // Cursor index (cursors.bam)
	READ_SHORT	(GW_door_offset + 0x006c) fj_trap_detect                // Trap detection difficulty
	READ_SHORT	(GW_door_offset + 0x006e) fj_trap_remove                // Trap removal difficulty
	READ_SHORT	(GW_door_offset + 0x0070) fj_trap_active                // Door is trapped (0=No, 1=Yes)
	READ_SHORT	(GW_door_offset + 0x0072) fj_trap_status                // Trap detected (0=No, 1=Yes)
	READ_SHORT	(GW_door_offset + 0x0074) fj_trap_loc_x                 // Trap launch target X coordinate
	READ_SHORT	(GW_door_offset + 0x0076) fj_trap_loc_y                 // Trap launch target Y coordinate
	READ_ASCII	(GW_door_offset + 0x0078) fj_key_resref (8) NULL        // Key item
	READ_ASCII	(GW_door_offset + 0x0080) fj_door_script (8) NULL       // Door script
	READ_LONG	(GW_door_offset + 0x0088) fj_detect_diff                // Detection difficulty (secret doors)
	READ_LONG	(GW_door_offset + 0x008c) fj_locked_diff                // Lock difficulty (0-100)
	READ_SHORT	(GW_door_offset + 0x0090) fj_open_loc_x                 // X location to open the door (when open)
	READ_SHORT	(GW_door_offset + 0x0092) fj_open_loc_y                 // Y location to open the door (when open)
	READ_SHORT	(GW_door_offset + 0x0094) fj_closed_loc_x               // X location to open the door (when closed)
	READ_SHORT	(GW_door_offset + 0x0096) fj_closed_loc_y               // Y location to open the door (when closed)
	READ_LONG	(GW_door_offset + 0x0098) fj_lockpick_strref            // Lock-pick string
	READ_ASCII	(GW_door_offset + 0x009c) fj_travel_trigger (24) NULL   // Travel trigger name
	READ_LONG	(GW_door_offset + 0x00b4) fj_dlg_strref                 // Dialog speaker name
	READ_ASCII	(GW_door_offset + 0x00b8) fj_dlg_resref (8) NULL        // Dialog resref

END	// of DEFINE_PATCH_MACRO



/* ========================================================================================================================================= *
 *                                                                                                                                           *
 *            F U N C T I O N S    &    M A C R O S    R E L A T I V E    T O    A R E A    S T R U C T U R ES    P A T C H I N G            *
 *                                                                                                                                           *
 * ========================================================================================================================================= */


/* =========================================================================================================== *
 *  FUNCTION GW_PARSE_FLAGS : MODIFICATION de la valeur du flag d'une région d'un fichier ARE.                 *
 *                            MODIFIES the flag value of a region in a ARE file.                               *
 * ----------------------------------------------------------------------------------------------------------- *
 *  Lancée automatiquement avant de cloner une région si la variable %GW_flags_new% est différente de "same".  *
 *  Automatically run before cloning a region in a area if %GW_flags_new% variable is not set to "same".       *
 * ----------------------------------------------------------------------------------------------------------- *
 *  INT_VAR                                                                                                    *
 *    - fj_flags      = Area region original flag (automatically set by GW_CLONE_AREA_TRIGGER function).       *
 *  STR_VAR                                                                                                    *
 *    - GW_flags_new  = Region flags to be modified. Code format per bit: "BIT0=value;BIT1=value..."           *
 *  RET                                                                                                        *
 *    - new_fj_flags  = Returns the new modified region flag.                                                  *
 * =========================================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_PARSE_FLAGS~
    INT_VAR fj_flags     = 0
    STR_VAR GW_flags_new = ~~
    RET     new_fj_flags
BEGIN

	new_fj_flags = fj_flags
	PATCH_IF (NOT ~%GW_flags_new%~ STR_EQ ~~) BEGIN

		// 1. Initializes flags values
		// ---------------------------
		TEXT_SPRINT "gw_flag_area_region_BIT0"  "same" // Key required
		TEXT_SPRINT "gw_flag_area_region_BIT1"  "same" // Reset trap (for proximity triggers)
		TEXT_SPRINT "gw_flag_area_region_BIT2"  "same" // Party Required
		TEXT_SPRINT "gw_flag_area_region_BIT3"  "same" // Detectable
		TEXT_SPRINT "gw_flag_area_region_BIT4"  "same" // NPC activates
		TEXT_SPRINT "gw_flag_area_region_BIT5"  "same" // Active in tutorial area only
		TEXT_SPRINT "gw_flag_area_region_BIT6"  "same" // Anyone activates
		TEXT_SPRINT "gw_flag_area_region_BIT7"  "same" // No string
		TEXT_SPRINT "gw_flag_area_region_BIT8"  "same" // Deactivated (for proximity triggers)
		TEXT_SPRINT "gw_flag_area_region_BIT9"  "same" // Party only
		TEXT_SPRINT "gw_flag_area_region_BIT10" "same" // Alternative point
		TEXT_SPRINT "gw_flag_area_region_BIT11" "same" // Door closed

		// 2. Parsing flags entries
		// ------------------------
		SET flags = 0
		SET len_flags = STRING_LENGTH ~%GW_flags_new%~
		INNER_PATCH ~%GW_flags_new%~ BEGIN
			SET curOfs = 0
			WHILE (curOfs < len_flags) BEGIN
				SET ofs = INDEX_BUFFER(~;~ curOfs)
				PATCH_IF (ofs < 0) BEGIN SET ofs = len_flags END
				READ_ASCII curOfs bit (ofs - curOfs)
				TEXT_SPRINT EVAL ~flag_%flags%~ ~%bit%~
//				PATCH_PRINT "DEBUG CONTROL bit = %bit%"
				SET flags += 1
				SET curOfs = ofs + 1
			END
		END

		// 3. Parsing flags values
		// -----------------------
		FOR (b = 0 ; b < flags ; ++b) BEGIN
			TEXT_SPRINT flag_bit EVAL ~%flag_%b%%~
			SET strlen = STRING_LENGTH ~%flag_bit%~
			INNER_PATCH ~%flag_bit%~ BEGIN
				SET curOfs = 0
				SET ofs = INDEX_BUFFER(~=~ curOfs)
				PATCH_IF (ofs < 0) BEGIN SET ofs = strlen END
				READ_ASCII curOfs bit_nb (ofs - curOfs)
//				PATCH_PRINT ~DEBUG CONTROL bit_nb = %bit_nb%~
				READ_ASCII curOfs bit (ofs - curOfs)
				READ_ASCII (ofs + 1) bit_value (BUFFER_LENGTH - ofs - 1)
//				PATCH_PRINT ~DEBUG CONTROL %bit_nb% = %bit_value%~
				TEXT_SPRINT EVAL ~gw_flag_area_region_%bit_nb%~ ~%bit_value%~
			END
		END
//		SET bits = flags

/*		PATCH_PRINT "DEBUG CONTROL
gw_flag_area_region_BIT0  = %gw_flag_area_region_BIT0%
gw_flag_area_region_BIT1  = %gw_flag_area_region_BIT1%
gw_flag_area_region_BIT2  = %gw_flag_area_region_BIT2%
gw_flag_area_region_BIT3  = %gw_flag_area_region_BIT3%
gw_flag_area_region_BIT4  = %gw_flag_area_region_BIT4%
gw_flag_area_region_BIT5  = %gw_flag_area_region_BIT5%
gw_flag_area_region_BIT6  = %gw_flag_area_region_BIT6%
gw_flag_area_region_BIT7  = %gw_flag_area_region_BIT7%
gw_flag_area_region_BIT8  = %gw_flag_area_region_BIT8%
gw_flag_area_region_BIT9  = %gw_flag_area_region_BIT9%
gw_flag_area_region_BIT10 = %gw_flag_area_region_BIT10%
gw_flag_area_region_BIT11 = %gw_flag_area_region_BIT11%"*/

		// 3. Modifying area flag value
		// ----------------------------
		FOR (i = 0 ; i < 12 ; ++i) BEGIN
			TEXT_SPRINT new_flag EVAL "%gw_flag_area_region_BIT%i%%"
//			PATCH_PRINT "DEBUG CONTROL new_flag = %new_flag%"
			PATCH_IF IS_AN_INT %new_flag% BEGIN

				SET new_flag_value = new_flag
//				TEXT_SPRINT new_bit EVAL "BIT%i%"
//				PATCH_PRINT "DEBUG CONTROL gw_flag_area_region_BIT%i%  = %new_flag_value% - %new_bit% - new_fj_flags = %new_fj_flags%"

				PATCH_MATCH ~%i%~ WITH
					0  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT0) = BIT0) BEGIN
							new_fj_flags = (new_fj_flags & `BIT0)
//							PATCH_PRINT "Remove BIT0 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT0) = 0) BEGIN	// (THIS BOR BIT0)
							new_fj_flags = (new_fj_flags | BIT0)
//							PATCH_PRINT "Add BIT0 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					1  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT1) = BIT1) BEGIN
							new_fj_flags = (new_fj_flags & `BIT1)
//							PATCH_PRINT "Remove BIT1 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT1) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT1)
//						PATCH_PRINT "Add BIT1 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					2  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT2) = BIT2) BEGIN
							new_fj_flags = (new_fj_flags & `BIT2)
//						PATCH_PRINT "Remove BIT2 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT2) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT2)
//							PATCH_PRINT "Add BIT2 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					3  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT3) = BIT3) BEGIN
							new_fj_flags = (new_fj_flags & `BIT3)
//							PATCH_PRINT "Remove BIT3 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT3) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT3)
//							PATCH_PRINT "Add BIT3 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					4  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT4) = BIT4) BEGIN
							new_fj_flags = (new_fj_flags & `BIT4)
//							PATCH_PRINT "Remove BIT4 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT4) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT4)
//							PATCH_PRINT "Add BIT4 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					5  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT5) = BIT5) BEGIN
							new_fj_flags = (new_fj_flags & `BIT5)
//						PATCH_PRINT "Remove BIT5 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT5) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT5)
//							PATCH_PRINT "Add BIT5 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					6  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT6) = BIT6) BEGIN
							new_fj_flags = (new_fj_flags & `BIT6)
//							PATCH_PRINT "Remove BIT6 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT6) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT6)
//							PATCH_PRINT "Add BIT6 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					7  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT7) = BIT7) BEGIN
							new_fj_flags = (new_fj_flags & `BIT7)
//							PATCH_PRINT "Remove BIT7 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT7) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT7)
//							PATCH_PRINT "Add BIT7 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					8  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT8) = BIT8) BEGIN
							new_fj_flags = (new_fj_flags & `BIT8)
//							PATCH_PRINT "Remove BIT8 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT8) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT8)
//							PATCH_PRINT "Add BIT8 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					9  BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT9) = BIT9) BEGIN
							new_fj_flags = (new_fj_flags & `BIT9)
//						PATCH_PRINT "Remove BIT9 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT9) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT9)
//							PATCH_PRINT "Add BIT9 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					10 BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT10) = BIT10) BEGIN
							new_fj_flags = (new_fj_flags & `BIT10)
//							PATCH_PRINT "Remove BIT10 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT10) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT10)
//							PATCH_PRINT "Add BIT10 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					11 BEGIN
						PATCH_IF (new_flag_value = 0) AND ((new_fj_flags & BIT11) = BIT11) BEGIN
							new_fj_flags = (new_fj_flags & `BIT11)
//						PATCH_PRINT "Remove BIT11 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
						PATCH_IF (new_flag_value = 1) AND ((new_fj_flags & BIT11) = 0) BEGIN
							new_fj_flags = (new_fj_flags | BIT11)
//							PATCH_PRINT "Add BIT11 new_flag_value = %new_flag_value% - new_fj_flags = %new_fj_flags%"
						END
					END
					DEFAULT
				END // of PATCH_MATCH

			END // of PATCH_IF IS_AN_INT %new_flag%
//			PATCH_PRINT "DEBUG CONTROL new_fj_flags = %new_fj_flags%"

		END  // of FOR (i = 0 ; i < 12 ; ++i)

	END // of PATCH_IF (NOT ~%GW_flags_new%~ STR_EQ ~~)

END // of DEFINE_PATCH_FUNCTION


/* ========================================================================================================================= *
 *  FUNCTION GW_CLONE_AREA_TRIGGER : CLONAGE d'un trigger existant dans une carte.                                           *
 *                                   CLONE an existing trigger in a ARE file.                                                *
 * ------------------------------------------------------------------------------------------------------------------------- *
 *  RECHERCHE un trigger existant dans une carte pour le cloner, MODIFIE éventuellement ses paramètres, puis GÉNÈRE et       *
 *  LANCE automatiquement la fonction ADD_AREA_REGION_TRIGGER pour ajouter le clone de ce trigger.                           *
 *  LOOKS for an existing trigger in a ARE file to clone it, MODIFIES if needed its settings, then AUTO-GENERATE and         *
 *  LAUNCH the ADD_AREA_REGION_TRIGGER function to add the trigger clone.                                                    *
 * ------------------------------------------------------------------------------------------------------------------------- *
 * Notes:                                                                                                                    *
 *    - Il faut obligatoirement renseigner l'une des deux variables GW_region_old ou GW_dest_old                             *
 *    - Vous pouvez restreindre les triggers à rechercher par type (variable GW_region_type).                                *
 *    - Il est possible de modifier manuellement les paramètres de la région à cloner.                                       *
 *    - You must at least assign a value to either GW_region_old or GW_dest_old variables.                                   *
 *    - You can narrow the triggers to look for by choosing a region type (GW_region_type variable).                         *
 *    - You can modify the trigger to clone settings.                                                                        *
 * ------------------------------------------------------------------------------------------------------------------------- *
 *  INT_VAR                                                                                                                  *
 *    - GW_region_type  = Changer le type de région - Modify the Region type (0 = trap, 1 = info, 2 = travel, 99 = all).     *
 *    - GW_info_point   = Changer le message d'information de la région - Modify the Information text string reference.      *
 *    - GW_trap_detect  = Changer le niveau de difficulté de détection d'un piège - Modify the Trap detection difficulty.    *
 *    - GW_trap_remove  = Changer le niveau de difficulté de désamorçage d'un piège - Modify the Trap removal difficulty.    *
 *    - GW_trap_active  = Changer l'activation du piège d'une région - Modify whether the Region is trapped (0=No, 1=Yes).   *
 *    - GW_trap_status  = Changer le statut d'un piège - Modify the Trap status (0=No, 1=Yes).                               *
 *    - GW_launch_x     = Modifier les coordonnées X de lancement d'un piège - Modify the Trap launch X coordinate.          *
 *    - GW_launch_y     = Modifier les coordonnées Y de lancement d'un piège - Modify the Trap launch Y coordinate.          *
 *    - GW_alt_x        = Modifier les coordonnées alt Y du trigger - Modify the use point X coordinate.                     *
 *    - GW_alt_y        = Modifier les coordonnées alt Y du trigger - Modify the use point Y coordinate.                     *
 *  STR_VAR                                                                                                                  *
 *    - GW_region_old   = Region's name to clone (nom du trigger à cloner).                                                  *
 *    - GW_region_new   = Attribuer un nouveau nom à la region clonée - Give a new name to the cloned region.                *
 *    - GW_dest_old     = Carte de destination à trouver - Destination area to found.                                        *
 *    - GW_dest_new     = Changer la carte de destination - Modify the Destination area resource reference.                  *
 *    - GW_entrance_new = Changer l'entrée dans la carte de destination - Modify the Entrance name in the destination area.  *
 *    - GW_key_new      = Modifier la clé pour activer le trigger - Modify the key to activate the trigger.                  *
 *    - GW_script_new   = Changer le script attribué à la région - Modify the region script.                                 *
 *    - GW_flags_new    = Changer les flags de la région - Modify the region flags (same = no change).                       *
 *      Flag bits set in bit format which are read right to left - 0 = off; 1 = on                                           *
 *      Code format per bit: "BIT0=value;BIT1=value..." - Supported bits:                                                    *
 *        BIT0: Key required [NI = Locked]                     - BIT1: Reset trap [NI = Trap resets] for proximity triggers  *
 *        BIT2: Party Required (for travel triggers)           - BIT3: Detectable [NI = Trap detectable                      *
 *        BIT4: NPC activates [NI = Trap set off by enemy]     - BIT5: Active in tutorial area only [NI = Tutorial trigger]  *
 *        BIT6: Anyone activates [NI = Trap set off by NPC]    - BIT7: No string [NI = Trigger silent]                       *
 *        BIT8: Trigger Deactivated (for proximity triggers)   - BIT9: Party only [NI = Cannot by passed by NPC]             *
 *        BIT10: Alternative point [NI = Use activation point] - BIT11: Door closed [NI = Connected to door]                 *
 *        Example: "BIT1=1;BIT9=0" adds BIT1 and remove BIT9                                                                 *
 * ========================================================================================================================= */

DEFINE_PATCH_FUNCTION ~GW_CLONE_AREA_TRIGGER~
    INT_VAR GW_region_type  = 99     // Optional: Region type (0 = trap/proximity, 1 = info, 2 = travel). 99 By default = all triggers.
            GW_info_point   = "-2"   // Optional: Information text string reference (for info points) [RESOLVE (@nnnn)]. Default(-2) = use whatever is in the original.
            GW_trap_detect  = "-1"   // Optional: Trap detection difficulty percentage. Default (-1) is to use the original.
            GW_trap_remove  = "-1"   // Optional: Trap removal difficulty percentage. Default (-1) is to use the original.
            GW_trap_active  = "-1"   // Optional: Whether the trap is set (0=no, 1=yes). Default (-1) is to use the original.
            GW_trap_status  = "-1"   // Optional: Whether the trap is set (0=no, 1=yes). Default (-1) is to use the original.
//            GW_launch_x     = "-2"   // Optional: Trap launch X coordinate. NOT YET modifiable
//            GW_launch_y     = "-2"   // Optional: Trap launch y coordinate. NOT YET modifiable
//            GW_alt_x        = "-2"   // Optional: Alternative use point X coordinate. NOT YET modifiable
//            GW_alt_y        = "-2"   // Optional: Alternative use point Y coordinate. NOT YET modifiable
    STR_VAR GW_region_old   = ""     // Optional: Region's name to clone. By default, the function uses the first trigger found for the given destination (GW_dest_old). Either region destination or name must be provided.
            GW_region_new   = ""     // Required: New cloned region's name.
            GW_dest_old     = ""     // Optional: Carte de destination à trouver (destination area to found). By default, the function uses the one that matches the passed name (GW_region_old).
            GW_dest_new     = ""     // Required: Carte de destination du trigger cloné (destination area for the new travel trigger).
            GW_entrance_new = "same" // Optional: Entrance name in the destination area (for travel regions). By default, the function uses whatever is in the original.
            GW_key_new      = "same" // Optional: Filename of the regions key. Default is to use the original.
            GW_script_new   = "same" // Optional: Filename of the Region script. Default is to use the original.
            GW_flags_new    = "same" // Optional: Flag. Default is to use whatever is in the original
BEGIN

	SET GW_clone_trigger = 0
	SET GW_name_len = 8
	SET match_reg_type = 0
	SPRINT GW_ab_RT_Vx ""
	SPRINT GW_add_trigger ""

	// 1. Checks variables validity.
	// -----------------------------
	// Either region name or destination needs to be provided
	PATCH_IF (("%GW_region_old%" STR_CMP "") OR ("%GW_dest_old%" STR_CMP "")) BEGIN

		SET GW_run_function = 1
		PATCH_IF ("%GW_region_old%" STR_CMP "") BEGIN // If a region name has been provided
			GW_name_len = STRING_LENGTH ~%GW_region_old%~
		END

		PATCH_IF ("%GW_info_point%" < "-1") BEGIN
            GW_info_point   = "-2"
		END

		PATCH_IF (GW_trap_detect < 0 AND GW_trap_detect > 255) BEGIN
            GW_trap_detect = "-1"
		END

		PATCH_IF (GW_trap_remove < 0 AND GW_trap_remove > 255) BEGIN
            GW_trap_remove = "-1"
		END

		PATCH_IF (GW_trap_active < 0 AND GW_trap_active > 1) BEGIN
			GW_trap_active = "-1"
		END

		PATCH_IF (GW_trap_status < 0 AND GW_trap_status > 1) BEGIN
            GW_trap_status = "-1"
		END


	END ELSE BEGIN
		SET GW_run_function = 0
		PATCH_PRINT "Please enter either region name or destination name to be cloned."
	END

	// 2. Only run the function with valid variables.
	// ----------------------------------------------
	PATCH_IF GW_run_function BEGIN

		// 2.1. First, we seek the region to clone.
		// ----------------------------------------
		LPF ~GW_READ_AREA_STRUCTURE~ RET GW_are_regions_num GW_are_regions_off GW_are_vertices_off GW_are_vertices_num END

		// Looping through regions
		FOR (r = 0 ; ((r < GW_are_regions_num) AND (GW_clone_trigger = 0) AND (GW_are_regions_num < 255)) ; ++r) BEGIN

			SET GW_region_offset = "%GW_are_regions_off%" + ("%GW_are_region_size%" * r)

			PATCH_IF (GW_region_type != 99) BEGIN
				READ_SHORT (GW_region_offset + 0x0020) reg_type // Region type (0=trap, 1=info, 2=travel)
				SET match_reg_type = 1
			END

			// There are cases where there is more than one region leading to the same destination
			// Need to also optionally include the name of the region in this case o test both the name and the destination
			READ_ASCII (GW_region_offset         ) region_name (%GW_name_len%) NULL // Region name
			READ_ASCII (GW_region_offset + 0x0038) destination_area (8) NULL        // Destination area resource reference (for travel regions)

			PATCH_IF match_reg_type BEGIN
				PATCH_IF (reg_type = GW_region_type) AND (("%region_name%" STR_EQ "%GW_region_old%") OR ("%GW_region_old%" STR_EQ "")) AND (("%destination_area%" STR_EQ "%GW_dest_old%") OR ("%GW_dest_old%" STR_EQ "")) BEGIN
					SET GW_clone_trigger = 1   // On a trouvé un travel trigger à cloner
					SET r = GW_are_regions_num // region found : stop the process
				END
			END ELSE BEGIN
				PATCH_IF (("%region_name%" STR_EQ "%GW_region_old%") OR ("%GW_region_old%" STR_EQ "")) AND (("%destination_area%" STR_EQ "%GW_dest_old%") OR ("%GW_dest_old%" STR_EQ "")) BEGIN
					SET GW_clone_trigger = 1
					SET r = GW_are_regions_num
				END
			END

		END // of Looping through regions

		// 2.2. If we found region to clone.
		// ---------------------------------
		PATCH_IF (GW_clone_trigger) BEGIN

			// 2.2.1. We read the region settings to copy them into a new region.
			// ------------------------------------------------------------------
			LPM ~GW_READ_AREA_REGION_STRUCTURE~

			// 2.2.2. Don't forget to build the region vertex array! (Pour chaque vertex du trigger, on stocke ses coordonnées X et Y).
			// -----------------------------------------------------
			FOR (v = 0 ; v < gw_reg_nb_vertices ; ++v) BEGIN
				SET vertex_offset = ("%GW_are_vertices_off%" + ((v + gw_reg_first_vertex) * 0x04))
				READ_SHORT  "%vertex_offset%"       	vertex_X
				READ_SHORT ("%vertex_offset%" + 0x02)	vertex_Y

				SPRINT ab_RT_Vx_X_v EVAL "ab_RT_Vx_X_%v%"
				SPRINT ab_RT_Vx_Y_v EVAL "ab_RT_Vx_Y_%v%"

				SPRINT GW_ab_RT_Vertex EVAL "ab_RT_Vx_X_%v% = %vertex_X% ab_RT_Vx_Y_%v% = %vertex_Y% "
				SPRINT GW_ab_RT_Vx EVAL "%GW_ab_RT_Vx%%GW_ab_RT_Vertex%"
			END // of looping through vertex


			// 2.2.3. We modify new region settings if needed.
			// -----------------------------------------------
			PATCH_IF ("%GW_flags_new%" STR_CMP "same") BEGIN
				LPF ~GW_PARSE_FLAGS~ INT_VAR fj_flags STR_VAR GW_flags_new RET new_fj_flags END
				SET fj_flags = new_fj_flags
			END
//			SET fj_flags = (GW_flags_new < 9999) ? GW_flags_new : fj_flags //< 4096

			// Optional: Information text string reference (for info points). Default (-2) = use whatever is in the original.
			SET fj_info_point_strref = (GW_info_point = "-2") ? fj_info_point_strref : GW_info_point

			// Optional: Trap detection difficulty percentage. Default is to use the original.
			SET fj_trap_detect = (GW_trap_detect <0) ? fj_trap_detect : GW_trap_detect

			// Optional: Trap removal difficulty percentage. Default is to use the original.
			SET fj_trap_remove = (GW_trap_remove <0) ? fj_trap_remove : GW_trap_remove

			// Optional: Whether the trap is set (0=no, 1=yes). Default is to use the original.
			SET fj_trap_active = (GW_trap_active <0) ? fj_trap_active : GW_trap_active
 
			// Optional: Whether the trap is detected (0=no, 1=yes). Default is to use the original.
			SET fj_trap_status = (GW_trap_status <0) ? fj_trap_status : GW_trap_status

			// Optional: Entrance name in the destination area (for travel regions). By default, the function uses whatever is in the original.
			PATCH_IF ("%GW_entrance_new%" STR_CMP "same") BEGIN
				SPRINT fj_destination_name EVAL "%GW_entrance_new%"
			END

			// Optional: Filename of the regions key. Default is to use the original.
 			PATCH_IF ("%GW_key_new%" STR_CMP "same") BEGIN
				SPRINT fj_key_resref EVAL "%GW_key_new%"
			END

			// Optional: Filename of the Region script. Default is to use the original.
			PATCH_IF ("%GW_script_new%" STR_CMP "same") BEGIN
				SPRINT fj_reg_script EVAL "%GW_script_new%"
			END


			// 2.2.4. On stocke les variables du trigger pour le cloner. - Memorize region settings before cloning.
			// ----------------------------------------------------------------------------------------------------
			SPRINT GW_add_trigger "LPF ~ADD_AREA_REGION_TRIGGER~ INT_VAR ab_RT_Type = %fj_type% ab_RT_BbLX = %fj_box_left% ab_RT_BbLY = %fj_box_top% ab_RT_BbHX = %fj_box_right% ab_RT_BbHY = %fj_box_bottom% ab_RT_VxPr = %gw_reg_nb_vertices% ab_RT_CuId = %fj_cursor_idx% ab_RT_Fbit = %fj_flags% ab_RT_Itxt = ~%fj_info_point_strref%~ ab_RT_TDtD = %fj_trap_detect% ab_RT_TRmD = %fj_trap_remove% ab_RT_TSet = %fj_trap_active% ab_RT_TDet = %fj_trap_status% ab_RT_LPoX = %fj_loc_x% ab_RT_LPoY = %fj_loc_y% ab_RT_ALPX = %fj_alt_x% ab_RT_ALPY = %fj_alt_y% %GW_ab_RT_Vx%"
//PATCH_PRINT "%GW_add_trigger%"
			SPRINT GW_add_trigger EVAL "%GW_add_trigger% STR_VAR ab_RT_Name = %GW_region_new%"
			PATCH_IF (fj_type = 2) BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_Dest = %GW_dest_new% ab_RT_EntN = %fj_destination_name%"
			END
//PATCH_PRINT "%GW_add_trigger%"

			// Cas particulier : si la variable %fj_key_resref% est vide, on ne la prend pas en compte pour éviter à la fonction ADD_AREA_TRIGGER de bugger.
			// Special case: discard %fj_key_resref% variable if empty to avoid ADD_AREA_TRIGGER function to fail.
			PATCH_IF ("%fj_key_resref%" STRING_COMPARE_CASE "") BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_KeyI = %fj_key_resref%"
			END
//PATCH_PRINT "%GW_add_trigger%"

			// Cas particulier : si la variable %fj_reg_script% est vide, on ne la prend pas en compte pour éviter à la fonction ADD_AREA_TRIGGER de bugger.
			// Special case: discard %fj_reg_script% variable if empty to avoid ADD_AREA_TRIGGER function to fail.
			PATCH_IF("%fj_reg_script%" STRING_COMPARE_CASE "") BEGIN
				SPRINT GW_add_trigger EVAL "%GW_add_trigger% ab_RT_Rbcs = %fj_reg_script%"
			END
//PATCH_PRINT "%GW_add_trigger%"

			SPRINT GW_add_trigger EVAL "%GW_add_trigger% END"
//PATCH_PRINT "%GW_add_trigger%"


			// 2.2.5. On clone le trigger. - At last, we clone the trigger.
			// ------------------------------------------------------------
			LPF ~GW_REINCLUDE~ STR_VAR GW_input = EVAL ~%GW_add_trigger%~ END

		END	ELSE BEGIN
			PATCH_PRINT "Region %GW_region_old% and destination %GW_dest_old% not found in area file."
			PATCH_SILENT
		END	// of PATCH_IF (GW_clone_trigger)

	END // of PATCH_IF GW_run_function BEGIN

END // of DEFINE_PATCH_FUNCTION
